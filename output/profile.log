SCRIPT  /private/var/mobile/Containers/Data/Application/5BBD46E8-CB4A-409E-9663-CDC3B9F17DEC/Documents/.vim/pack/my_pac/start/ultisnips/autoload/UltiSnips.vim
Sourced 1 time
Total time:   0.336455
 Self time:   0.336455

count  total (s)   self (s)
    1              0.000027 if exists("b:did_autoload_ultisnips")
                                finish
    1              0.000002 endif
    1              0.000006 let b:did_autoload_ultisnips = 1
                            
                            " Also import vim as we expect it to be imported in many places.
    1              0.081518 py3 import vim
    1              0.253636 py3 from UltiSnips import UltiSnips_Manager
                            
    1              0.000004 function! s:compensate_for_pum() abort
                                """ The CursorMovedI event is not triggered while the popup-menu is visible,
                                """ and it's by this event that UltiSnips updates its vim-state. The fix is
                                """ to explicitly check for the presence of the popup menu, and update
                                """ the vim-state accordingly.
                                if pumvisible()
                                    py3 UltiSnips_Manager._cursor_moved()
                                endif
                            endfunction
                            
    1              0.000002 function! UltiSnips#Edit(bang, ...) abort
                                if a:0 == 1 && a:1 != ''
                                    let type = a:1
                                else
                                    let type = ""
                                endif
                                py3 vim.command("let file = '%s'" % UltiSnips_Manager._file_to_edit(vim.eval("type"), vim.eval('a:bang')))
                            
                                if !len(file)
                                   return
                                endif
                            
                                let mode = 'e'
                                if exists('g:UltiSnipsEditSplit')
                                    if g:UltiSnipsEditSplit == 'vertical'
                                        let mode = 'vs'
                                    elseif g:UltiSnipsEditSplit == 'horizontal'
                                        let mode = 'sp'
                                    elseif g:UltiSnipsEditSplit == 'tabdo'
                                        let mode = 'tabedit'
                                    elseif g:UltiSnipsEditSplit == 'context'
                                        let mode = 'vs'
                                        if winwidth(0) <= 2 * (&tw ? &tw : 80)
                                            let mode = 'sp'
                                        endif
                                    endif
                                endif
                                exe ':'.mode.' '.escape(file, ' ')
                            endfunction
                            
    1              0.000002 function! UltiSnips#AddFiletypes(filetypes) abort
                                py3 UltiSnips_Manager.add_buffer_filetypes(vim.eval("a:filetypes"))
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#FileTypeComplete(arglead, cmdline, cursorpos) abort
                                let ret = {}
                                let items = map(
                                \   split(globpath(&runtimepath, 'syntax/*.vim'), '\n'),
                                \   'fnamemodify(v:val, ":t:r")'
                                \ )
                                call insert(items, 'all')
                                for item in items
                                    if !has_key(ret, item) && item =~ '^'.a:arglead
                                        let ret[item] = 1
                                    endif
                                endfor
                            
                                return sort(keys(ret))
                            endfunction
                            
    1              0.000001 function! UltiSnips#ExpandSnippet() abort
                                py3 UltiSnips_Manager.expand()
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#ExpandSnippetOrJump() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.expand_or_jump()
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#ListSnippets() abort
                                py3 UltiSnips_Manager.list_snippets()
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#SnippetsInCurrentScope(...) abort
                                let g:current_ulti_dict = {}
                                let all = get(a:, 1, 0)
                                if all
                                  let g:current_ulti_dict_info = {}
                                endif
                                py3 UltiSnips_Manager.snippets_in_current_scope(int(vim.eval("all")))
                                return g:current_ulti_dict
                            endfunction
                            
    1              0.000002 function! UltiSnips#SaveLastVisualSelection() range abort
                                py3 UltiSnips_Manager._save_last_visual_selection()
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#JumpBackwards() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_backwards()
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#JumpForwards() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_forwards()
                                return ""
                            endfunction
                            
    1              0.000003 function! UltiSnips#AddSnippetWithPriority(trigger, value, description, options, filetype, priority) abort
                                py3 trigger = vim.eval("a:trigger")
                                py3 value = vim.eval("a:value")
                                py3 description = vim.eval("a:description")
                                py3 options = vim.eval("a:options")
                                py3 filetype = vim.eval("a:filetype")
                                py3 priority = vim.eval("a:priority")
                                py3 UltiSnips_Manager.add_snippet(trigger, value, description, options, filetype, priority)
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#Anon(value, ...) abort
                                " Takes the same arguments as SnippetManager.expand_anon:
                                " (value, trigger="", description="", options="")
                                py3 args = vim.eval("a:000")
                                py3 value = vim.eval("a:value")
                                py3 UltiSnips_Manager.expand_anon(value, *args)
                                return ""
                            endfunction
                            
    1              0.000001 function! UltiSnips#CursorMoved() abort
                                py3 UltiSnips_Manager._cursor_moved()
                            endf
                            
    1              0.000002 function! UltiSnips#LeavingBuffer() abort
                                let from_preview = getwinvar(winnr('#'), '&previewwindow')
                                let to_preview = getwinvar(winnr(), '&previewwindow')
                            
                                if !(from_preview || to_preview)
                                    py3 UltiSnips_Manager._leaving_buffer()
                                endif
                            endf
                            
    1              0.000001 function! UltiSnips#LeavingInsertMode() abort
                                py3 UltiSnips_Manager._leaving_insert_mode()
                            endfunction
                            
    1              0.000001 function! UltiSnips#TrackChange() abort
                                py3 UltiSnips_Manager._track_change()
                            endfunction
                            
    1              0.000001 function! UltiSnips#RefreshSnippets() abort
                                py3 UltiSnips_Manager._refresh_snippets()
                            endfunction
                            " }}}

SCRIPT  /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/scripts.vim
Sourced 1 time
Total time:   0.001196
 Self time:   0.001196

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2019 Jun 25
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    1              0.000010 if did_filetype()
                              finish
    1              0.000001 endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    1              0.000006 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    1              0.000000 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000010 let s:cpo_save = &cpo
    1              0.000013 set cpo&vim
                            
    1              0.000006 let s:line1 = getline(1)
                            
    1              0.000010 if s:line1 =~# "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make
                            
                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike
                            
                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~# 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~# 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby
                            
                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript
                            
                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~# 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang
                            
                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell
                            
                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala
                            
                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure
                            
                              endif
                              unlet s:name
                            
    1              0.000001 else
                              " File does not start with "#!".
                            
    1              0.000002   let s:line2 = getline(2)
    1              0.000002   let s:line3 = getline(3)
    1              0.000002   let s:line4 = getline(4)
    1              0.000001   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    1              0.000003   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                              " Z shell scripts
    1              0.000052   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
    1              0.000014   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                              " Mason
    1              0.000005   elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason
                            
                              " Vim scripts (must have '" vim' as the first line to trigger this)
    1              0.000003   elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim
                            
                              " libcxx and libstdc++ standard library headers like "iostream" do not have
                              " an extension, recognize the Emacs file mode.
    1              0.000004   elseif s:line1 =~? '-\*-.*C++.*-\*-'
                                set ft=cpp
                            
                              " MOO
    1              0.000007   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
    1              0.000060   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
    1              0.000003   elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
    1              0.000014   elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
    1              0.000004   elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
    1              0.000018   elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
    1              0.000003   elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
    1              0.000003   elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
    1              0.000003   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
    1              0.000004   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
    1              0.000003   elseif s:line1 =~# '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
    1              0.000015   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
    1              0.000006   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
    1              0.000005   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
    1              0.000002   elseif s:line1 =~# '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
    1              0.000002   elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
    1              0.000004   elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
    1              0.000004   elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
    1              0.000003   elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
    1              0.000010   elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
    1              0.000018   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
    1              0.000004   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
    1              0.000005   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
    1              0.000004   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
    1              0.000003   elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
    1              0.000003   elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
    1              0.000018   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
    1              0.000013   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan
                            
                              " Valgrind
    1              0.000006   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
    1              0.000004   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
    1              0.000003   elseif s:line1 =~# '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
    1              0.000005   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
    1              0.000018   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
    1              0.000002    elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
    1              0.000003   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " CVS diff
    1              0.000001   else
    1              0.000001     let s:lnum = 1
    1              0.000005     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
    1              0.000001     endwhile
    1              0.000004     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
    1              0.000018     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
    1              0.000001     endif
    1              0.000001     unlet s:lnum
                            
    1              0.000000   endif
                            
    1              0.000002   unlet s:line2 s:line3 s:line4 s:line5
                            
    1              0.000001 endif
                            
                            " Restore 'cpoptions'
    1              0.000006 let &cpo = s:cpo_save
                            
    1              0.000003 unlet s:cpo_save s:line1

SCRIPT  /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/ftplugin/text.vim
Sourced 1 time
Total time:   0.000490
 Self time:   0.000490

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		Text
                            " Maintainer:		David Barnett <daviebdawg+vim@gmail.com>
                            " Last Change:		2019 Jan 10
                            
    1              0.000005 if exists('b:did_ftplugin')
                              finish
    1              0.000001 endif
    1              0.000002 let b:did_ftplugin = 1
                            
    1              0.000002 let b:undo_ftplugin = 'setlocal comments< commentstring<'
                            
                            " We intentionally don't set formatoptions-=t since text should wrap as text.
                            
                            " Pseudo comment leaders to indent bulleted lists with '-' and '*'.  And allow
                            " for Mail quoted text with '>'.
    1              0.000005 setlocal comments=fb:-,fb:*,n:>
    1              0.000004 setlocal commentstring=

FUNCTION  <SNR>3_SynSet()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/syntax/synload.vim:33
Called 1 time
Total time:   0.004665
 Self time:   0.004665

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000004   syn clear
    1              0.000003   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000002   let s = expand("<amatch>")
    1              0.000001   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    2              0.000006     for name in split(s, '\.')
    1              0.004628       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    2              0.000002     endfor
    1              0.000001   endif

FUNCTION  cursorword#cursormoved()
    Defined: ~/.vim/pack/my_pac/start/vim-cursorword/autoload/cursorword.vim:45
Called 11 times
Total time:   0.000601
 Self time:   0.000601

count  total (s)   self (s)
   11              0.000098     if get(w:, 'cursorword_match')
    4              0.000045       silent! call matchdelete(w:cursorword_id0)
    4              0.000044       silent! call matchdelete(w:cursorword_id1)
    4              0.000016       let w:cursorword_match = 0
    4              0.000021       let w:cursorword_state = []
   11              0.000018     endif
   11              0.000077     call timer_stop(s:timer)
   11              0.000104     let s:timer = timer_start(s:delay, 'cursorword#timer_callback')

FUNCTION  <SNR>57_LogAction()
    Defined: ~/.vim/pack/my_pac/start/activity-log.vim/plugin/activity-log.vim:101
Called 1 time
Total time:   0.002548
 Self time:   0.000138

count  total (s)   self (s)
    1              0.000003 	if g:activity_log_location == ''
                            		return
    1              0.000001 	endif
                            
    1              0.000074 	let l:file = fnameescape(expand("%:p"))
    1              0.000001 	if empty(l:file)
                            		return
    1              0.000001 	endif
    1              0.000015 	let l:time = strftime('%Y-%m-%d %H:%M:%S')
                            
    1              0.000002 	if a:action != "write"
                            		if !has_key(s:UnsavedStack, l:file)
                            			let s:UnsavedStack[l:file] = {}
                            		endif
                            		let s:UnsavedStack[l:file][a:action] = l:time
                            		return
    1              0.000001 	endif
                            
    1              0.000002 	if len(s:UnsavedStack) && has_key(s:UnsavedStack, l:file)
                            		for [key, value] in items(s:UnsavedStack[l:file])
                            			let l:message = value . ' ' . key  . ' ' . l:file
                            			call s:WriteLogAction(l:message)
                            		endfor
                            		let s:UnsavedStack[l:file] = {}
    1              0.000000 	endif
                            
    1              0.000003 	let l:message = l:time . ';' . a:action  . ';' . l:file
                            
    1              0.000002 	if g:activity_log_append_git_branch
                            		let l:branch = system('cd ' . fnameescape(expand("%:h")) . "; git rev-parse -q --abbrev-ref HEAD 2> /dev/null")
                            		let l:message = l:message . ';' . substitute(l:branch, '\v\C\n$', '', '')
    1              0.000000 	endif
    1   0.002418   0.000008 	call s:WriteLogAction(l:message)

FUNCTION  <SNR>8_LoadFTPlugin()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/ftplugin.vim:14
Called 1 time
Total time:   0.004793
 Self time:   0.004255

count  total (s)   self (s)
    1              0.000002     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000000     endif
                            
    1              0.000002     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000005       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000005       for name in split(s, '\.')
    1   0.004764   0.004226 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    2              0.000002       endfor
    1              0.000001     endif

FUNCTION  <SNR>65_MRU_AddFile()
    Defined: ~/.vim/pack/my_pac/start/mru.vim/plugin/mru.vim:168
Called 1 time
Total time:   0.002562
 Self time:   0.000386

count  total (s)   self (s)
    1              0.000001     if s:mru_list_locked
                                    " MRU list is currently locked
                                    return
    1              0.000001     endif
                            
                                " Get the full path to the filename
    1              0.000075     let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
    1              0.000002     if fname == ''
                                    return
    1              0.000001     endif
                            
                                " Skip temporary buffers with buftype set. The buftype is set for buffers
                                " used by plugins.
    1              0.000002     if &buftype != ''
                                    return
    1              0.000001     endif
                            
    1              0.000002     if g:MRU_Include_Files != ''
                                    " If MRU_Include_Files is set, include only files matching the
                                    " specified pattern
                                    if fname !~# g:MRU_Include_Files
                                        return
                                    endif
    1              0.000001     endif
                            
    1              0.000001     if g:MRU_Exclude_Files != ''
                                    " Do not add files matching the pattern specified in the
                                    " MRU_Exclude_Files to the MRU list
                                    if fname =~# g:MRU_Exclude_Files
                                        return
                                    endif
    1              0.000000     endif
                            
                                " If the filename is not already present in the MRU list and is not
                                " readable then ignore it
    1              0.000004     let idx = index(s:MRU_files, fname)
    1              0.000001     if idx == -1
    1              0.000035         if !filereadable(fname)
                                        " File is not readable and is not in the MRU list
                                        return
    1              0.000000         endif
    1              0.000000     endif
                            
                                " Load the latest MRU file list
    1   0.000903   0.000009     call s:MRU_LoadList()
                            
                                " Remove the new file name from the existing MRU list (if already present)
    1              0.000006     call filter(s:MRU_files, 'v:val !=# fname')
                            
                                " Add the new file list to the beginning of the updated old file list
    1              0.000002     call insert(s:MRU_files, fname, 0)
                            
                                " Trim the list
    1              0.000002     if len(s:MRU_files) > g:MRU_Max_Entries
                                    call remove(s:MRU_files, g:MRU_Max_Entries, -1)
    1              0.000000     endif
                            
                                " Save the updated MRU list
    1   0.000740   0.000012     call s:MRU_SaveList()
                            
                                " Refresh the MRU menu
    1   0.000565   0.000011     call s:MRU_Refresh_Menu()
                            
                                " If the MRU window is open, update the displayed MRU list
    1              0.000002     let bname = s:MRU_buf_name
    1              0.000177     let winnum = bufwinnr(bname)
    1              0.000002     if winnum != -1
                                    let cur_winnr = winnr()
                                    call s:MRU_Open_Window()
                                    if winnr() != cur_winnr
                                        exe cur_winnr . 'wincmd w'
                                    endif
    1              0.000001     endif

FUNCTION  <SNR>6_BMRemove()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/menu.vim:669
Called 1 time
Total time:   0.000296
 Self time:   0.000125

count  total (s)   self (s)
    1              0.000014   if s:bmenu_wait == 0
    1              0.000015     let name = expand("<afile>")
    1              0.000006     if isdirectory(name)
                                  return
    1              0.000002     endif
    1   0.000204   0.000033     let munge = <SID>BMMunge(name, expand("<abuf>"))
                            
    1              0.000004     if s:bmenu_short == 0
    1              0.000022       exe 'silent! aun &Buffers.' . munge
                                else
                                  exe 'silent! aun &Buffers.' . <SID>BMHash2(munge) . munge
    1              0.000001     endif
    1              0.000010     let s:bmenu_count = s:bmenu_count - 1
    1              0.000002   endif

FUNCTION  <SNR>58_collect_location()
    Defined: ~/.vim/pack/my_pac/start/completion-dict.vim/plugin/vim_dict.vim:50
Called 1 time
Total time:   0.002741
 Self time:   0.002741

count  total (s)   self (s)
    1              0.000002 	let source = []
    2              0.000003 	for name in a:locations
    1              0.000376 		let name = fnamemodify(name, ':p')
    1              0.000021 		if name =~ '^.\+[\/\\]$'
    1              0.000006 			let name = strpart(name, 0, strlen(name) - 1)
    1              0.000001 		endif
    1              0.000196 		let source += [expand(name)]
    2              0.000003 	endfor
    1              0.000004 	let paths = join(source, ',')
    1              0.002114 	let names = globpath(paths, '**/' . a:ft . '.*')
    1              0.000006 	return split(names, "\n")

FUNCTION  <SNR>65_MRU_SaveList()
    Defined: ~/.vim/pack/my_pac/start/mru.vim/plugin/mru.vim:158
Called 1 time
Total time:   0.000728
 Self time:   0.000728

count  total (s)   self (s)
    1              0.000001     let l = []
    1              0.000003     call add(l, '# Most recently edited files in Vim (version 3.0)')
    1              0.000002     call extend(l, s:MRU_files)
    1              0.000722     call writefile(l, g:MRU_File)

FUNCTION  <SNR>65_MRU_Refresh_Menu()
    Defined: ~/.vim/pack/my_pac/start/mru.vim/plugin/mru.vim:781
Called 2 times
Total time:   0.001066
 Self time:   0.000200

count  total (s)   self (s)
    2              0.000007     if !has('menu') || !g:MRU_Add_Menu
                                    " No support for menus
                                    return
    2              0.000001     endif
                            
                                " Setup the cpoptions properly for the maps to work
    2              0.000004     let old_cpoptions = &cpoptions
    2              0.000008     set cpoptions&vim
                            
                                " Remove the MRU menu
                                " To retain the teared-off MRU menu, we need to add a dummy entry
    2              0.000013     silent! unmenu &File.&Recent\ Files
                                " The menu priority of the File menu is 10. If the MRU plugin runs
                                " first before menu.vim, the File menu order may not be correct.
                                " So specify the priority of the File menu here.
    2              0.000011     10noremenu &File.&Recent\ Files.Dummy <Nop>
    2              0.000011     silent! unmenu! &File.&Recent\ Files
                            
    2              0.000014     anoremenu <silent> &File.&Recent\ Files.Refresh\ list :call <SID>MRU_LoadList()<CR>
    2   0.000061   0.000026     exe 'tmenu File.&Recent\ Files.Refresh\ list Reload the MRU file list from ' . s:MRU_escape_filename(g:MRU_File)
    2              0.000008     anoremenu File.&Recent\ Files.-SEP1-           :
                            
                                " Add the filenames in the MRU list to the menu
    2              0.000004     let entry_cnt = len(s:MRU_files)
    2              0.000003     if entry_cnt > g:MRU_Max_Menu_Entries
                                    " Show only MRU_Max_Menu_Entries file names in the menu
                                    let mru_list = s:MRU_files[0 : g:MRU_Max_Menu_Entries - 1]
                                    let entry_cnt = g:MRU_Max_Menu_Entries
    2              0.000002     else
    2              0.000002         let mru_list = s:MRU_files
    2              0.000001     endif
    2              0.000004     if entry_cnt > g:MRU_Max_Submenu_Entries
                            	" Split the MRU menu into sub-menus
                                    for start_idx in range(0, entry_cnt, g:MRU_Max_Submenu_Entries)
                                        let last_idx = start_idx + g:MRU_Max_Submenu_Entries - 1
                                        if last_idx >= entry_cnt
                                            let last_idx = entry_cnt - 1
                                        endif
                                        let prefix = 'Files\ (' . (start_idx + 1) . '\.\.\.' . (last_idx + 1) . ').'
                                        call s:MRU_add_files_to_menu(prefix, mru_list[start_idx : last_idx])
                                    endfor
    2              0.000001     else
    2   0.000848   0.000017         call s:MRU_add_files_to_menu('', mru_list)
    2              0.000001     endif
                            
                                " Remove the dummy menu entry
    2              0.000004     unmenu &File.&Recent\ Files.Dummy
                            
                                " Restore the previous cpoptions settings
    2              0.000006     let &cpoptions = old_cpoptions

FUNCTION  <SNR>58_load_dict()
    Defined: ~/.vim/pack/my_pac/start/completion-dict.vim/plugin/vim_dict.vim:82
Called 1 time
Total time:   0.003185
 Self time:   0.000412

count  total (s)   self (s)
    1              0.000002 	let names = []
    1              0.000002 	let fts = [a:ft]
    1              0.000004 	if has_key(g:vim_dict_config, a:ft)
                            		let hh = g:vim_dict_config[a:ft]
                            		if type(hh) == v:t_list
                            			let fts = hh
                            		elseif type(hh) == v:t_string
                            			let fts = []
                            			for ft in split(hh, ',')
                            				let ft = substitute(ft, '^\s*\(.\{-}\)\s*$', '\1', '')
                            				if ft != ''
                            					let fts += [ft]
                            				endif
                            			endfor
                            		else
                            			let fts = []
                            		endif
    1              0.000001 	endif
    1              0.000003 	let dict = [s:dict] + g:vim_dict_dict
    1              0.000001 	let tags = [s:tags] + g:vim_dict_tags
    2              0.000002 	for ft in fts
    1   0.002750   0.000009 		let names = s:collect_location(ft, dict)
    2              0.000002 		for name in names
    1              0.000293 			if filereadable(name)
    1   0.000045   0.000013 				if s:contains(&dictionary, name) == 0
    1              0.000032 					exec 'setlocal dictionary+=' . fnameescape(name)
    1              0.000001 				endif
    1              0.000000 			endif
    2              0.000001 		endfor
    2              0.000001 	endfor
    1              0.000003 	if get(g:vim_dict_enable_tags, a:ft, 0) != 0
                            		let names = s:collect_location(a:ft, tags)
                            		for name in names
                            			if filereadable(name)
                            				if s:contains(&tags, name) == 0
                            					exec 'setlocal tags+=' . fnameescape(name)
                            				endif
                            			endif
                            		endfor
    1              0.000001 	endif

FUNCTION  <SNR>89_Disable()
    Defined: ~/.vim/pack/my_pac/start/indentLine/after/plugin/indentLine.vim:309
Called 1 time
Total time:   0.000077
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000003     if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
    1              0.000003     elseif exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    return
    1   0.000010   0.000004     elseif s:Filter() == 0
    1   0.000040   0.000007         call s:IndentLinesDisable()
    1   0.000018   0.000007         call s:LeadingSpaceDisable()
    1              0.000000     endif

FUNCTION  <SNR>89_InitColor()
    Defined: ~/.vim/pack/my_pac/start/indentLine/after/plugin/indentLine.vim:35
Called 1 time
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
    1              0.000002     if !g:indentLine_setColors
                                    return
    1              0.000001     endif
                            
    1              0.000002     let default_term_bg = "NONE"
    1              0.000002     let default_gui_bg  = "NONE"
    1              0.000002     if &background ==# "light"
                                    let default_term_fg = 249
                                    let default_gui_fg = "Grey70"
    1              0.000000     else
    1              0.000002         let default_term_fg = 239
    1              0.000001         let default_gui_fg = "Grey30"
    1              0.000001     endif
                            
    1              0.000002     if g:indentLine_defaultGroup != ""
                                    let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                    let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
                                    let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
                                    let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                    let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
    1              0.000000     endif
                            
    1              0.000002     if !exists("g:indentLine_color_term")
    1              0.000001         let term_color = default_term_fg
                                else
                                    let term_color = g:indentLine_color_term
    1              0.000001     endif
                            
    1              0.000003     if !exists("g:indentLine_bgcolor_term")
    1              0.000001         let term_bgcolor = default_term_bg
                                else
                                    let term_bgcolor = g:indentLine_bgcolor_term
    1              0.000001     endif
                            
    1              0.000002     if !exists("g:indentLine_color_gui")
    1              0.000001         let gui_color = default_gui_fg
                                else
                                    let gui_color = g:indentLine_color_gui
    1              0.000000     endif
                            
    1              0.000002     if !exists("g:indentLine_bgcolor_gui")
    1              0.000001         let gui_bgcolor = default_gui_bg
                                else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
    1              0.000000     endif
                            
    1              0.000035     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    1              0.000009     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    1              0.000002     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
    1              0.000000     endif

FUNCTION  <SNR>49_Highlight_Matching_Pair()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/plugin/matchparen.vim:39
Called 19 times
Total time:   0.004901
 Self time:   0.004901

count  total (s)   self (s)
                              " Remove any previous match.
   19              0.000209   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
   19              0.000046   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   19              0.000338   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   19              0.000034   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   19              0.000160   let c_lnum = line('.')
   19              0.000110   let c_col = col('.')
   19              0.000069   let before = 0
                            
   19              0.000128   let text = getline(c_lnum)
   19              0.000947   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   19              0.000136   if empty(matches)
                                let [c_before, c] = ['', '']
   19              0.000042   else
   19              0.000219     let [c_before, c] = matches[1:2]
   19              0.000040   endif
   19              0.000833   let plist = split(&matchpairs, '.\zs[:,]')
   19              0.000172   let i = index(plist, c)
   19              0.000058   if i < 0
                                " not found, in Insert mode try character before the cursor
   19              0.000170     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   16              0.000113       let before = strlen(c_before)
   16              0.000054       let c = c_before
   16              0.000097       let i = index(plist, c)
   19              0.000033     endif
   19              0.000056     if i < 0
                                  " not found, nothing to do
   19              0.000061       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  cursorword#matchadd()
    Defined: ~/.vim/pack/my_pac/start/vim-cursorword/autoload/cursorword.vim:23
Called 15 times
Total time:   0.002763
 Self time:   0.002763

count  total (s)   self (s)
   15              0.000443   let enable = get(b:, 'cursorword', get(g:, 'cursorword', 1)) && !has('vim_starting')
   15              0.000148   if !enable && !get(w:, 'cursorword_match') | return | endif
   15              0.000166   let i = (a:0 ? a:1 : mode() ==# 'i' || mode() ==# 'R') && col('.') > 1
   15              0.000082   let line = getline('.')
   15              0.000063   let linenr = line('.')
   15              0.000725   let word = matchstr(line[:(col('.')-i-1)], '\k*$') . matchstr(line[(col('.')-i-1):], '^\k*')[1:]
   15              0.000205   if get(w:, 'cursorword_state', []) ==# [ linenr, word, enable ] | return | endif
    8              0.000038   let w:cursorword_state = [ linenr, word, enable ]
    8              0.000100   silent! call matchdelete(w:cursorword_id0)
    8              0.000059   silent! call matchdelete(w:cursorword_id1)
    8              0.000026   let w:cursorword_match = 0
    8              0.000196   if !enable || word ==# '' || len(word) !=# strchars(word) && word !~# s:alphabets || len(word) > 1000 | return | endif
    5              0.000046   let pattern = '\<' . escape(word, '~"\.^$[]*') . '\>'
    5              0.000177   let w:cursorword_id0 = matchadd('CursorWord0', pattern, -100)
    5              0.000137   let w:cursorword_id1 = matchadd('CursorWord' . &l:cursorline, '\%' . linenr . 'l' . pattern, -100)
    5              0.000021   let w:cursorword_match = 1

FUNCTION  <SNR>62_Compare()
    Defined: ~/.vim/pack/my_pac/start/hiPairs.vim/plugin/hiPairs.vim:71
Called 26 times
Total time:   0.000384
 Self time:   0.000384

count  total (s)   self (s)
   26              0.000336     return a:a[0] == a:b[0] ? a:a[1]-a:b[1] : a:a[0]-a:b[0]

FUNCTION  <SNR>89_LeadingSpaceDisable()
    Defined: ~/.vim/pack/my_pac/start/indentLine/after/plugin/indentLine.vim:368
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000003         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
    1              0.000000         endif
                            
    1              0.000000         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/.vim/pack/my_pac/start/ultisnips/autoload/UltiSnips.vim:151
Called 19 times
Total time:   0.017395
 Self time:   0.017395

count  total (s)   self (s)
   19              0.017333     py3 UltiSnips_Manager._track_change()

FUNCTION  <SNR>6_BMFilename()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/menu.vim:779
Called 1 time
Total time:   0.000580
 Self time:   0.000165

count  total (s)   self (s)
    1              0.000019   if isdirectory(a:name)
                                return
    1              0.000002   endif
    1   0.000338   0.000020   let munge = <SID>BMMunge(a:name, a:num)
    1   0.000115   0.000018   let hash = <SID>BMHash(munge)
    1              0.000004   if s:bmenu_short == 0
    1              0.000010     let name = 'an ' . g:bmenu_priority . '.' . hash . ' &Buffers.' . munge
                              else
                                let name = 'an ' . g:bmenu_priority . '.' . hash . '.' . hash . ' &Buffers.' . <SID>BMHash2(munge) . munge
    1              0.000002   endif
                              " set 'cpo' to include the <CR>
    1              0.000010   let cpo_save = &cpo
    1              0.000018   set cpo&vim
    1              0.000030   exe name . ' :confirm b' . a:num . '<CR>'
    1              0.000012   let &cpo = cpo_save

FUNCTION  <SNR>9_LoadIndent()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/indent.vim:13
Called 1 time
Total time:   0.001301
 Self time:   0.001301

count  total (s)   self (s)
    1              0.000003     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    1              0.000001     endif
    1              0.000003     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000006       for name in split(s, '\.')
    1              0.001274 	exe 'runtime! indent/' . name . '.vim'
    2              0.000002       endfor
    1              0.000001     endif

FUNCTION  <SNR>65_MRU_escape_filename()
    Defined: ~/.vim/pack/my_pac/start/mru.vim/plugin/mru.vim:248
Called 11 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
   11              0.000020     if exists("*fnameescape")
   11              0.000151         return fnameescape(a:fname)
                                else
                                    return escape(a:fname, s:esc_filename_chars)
                                endif

FUNCTION  cursorword#timer_callback()
    Defined: ~/.vim/pack/my_pac/start/vim-cursorword/autoload/cursorword.vim:55
Called 11 times
Total time:   0.002540
 Self time:   0.000424

count  total (s)   self (s)
   11   0.002499   0.000383     call cursorword#matchadd()

FUNCTION  <SNR>89_ResetConcealOption()
    Defined: ~/.vim/pack/my_pac/start/indentLine/after/plugin/indentLine.vim:110
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    if exists("b:indentLine_original_concealcursor")
                                        let &l:concealcursor = b:indentLine_original_concealcursor
                                    endif
                                    if exists("b:indentLine_original_conceallevel")
                                        let &l:conceallevel = b:indentLine_original_conceallevel
                                    endif
                                    let b:indentLine_ConcealOptionSet = 0
    1              0.000001     endif

FUNCTION  <SNR>89_Filter()
    Defined: ~/.vim/pack/my_pac/start/indentLine/after/plugin/indentLine.vim:286
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000004     if index(g:indentLine_fileTypeExclude, &filetype) != -1
    1              0.000001         return 0
                                endif
                            
                                if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
                                endif
                            
                                if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
                                endif
                            
                                for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
                                endfor
                            
                                return 1

FUNCTION  <SNR>6_BMAdd()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/menu.vim:657
Called 1 time
Total time:   0.000863
 Self time:   0.000283

count  total (s)   self (s)
    1              0.000009   if s:bmenu_wait == 0
                                " when adding too many buffers, redraw in short format
    1              0.000007     if s:bmenu_count == &menuitems && s:bmenu_short == 0
                                  call s:BMShow()
    1              0.000003     else
    1   0.000817   0.000237       call <SID>BMFilename(expand("<afile>"), expand("<abuf>"))
    1              0.000006       let s:bmenu_count = s:bmenu_count + 1
    1              0.000009     endif
    1              0.000002   endif

FUNCTION  <SNR>66_SetUpForNewFiletype()
    Defined: ~/.vim/pack/my_pac/start/nerdcommenter/plugin/NERD_commenter.vim:526
Called 1 time
Total time:   0.000096
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000001     let filetype = a:filetype
                            
                                "for compound filetypes, if we don't know how to handle the full filetype
                                "then break it down and use the first part that we know how to handle
    1              0.000004     if filetype =~# '\.' && !has_key(s:delimiterMap, filetype)
                                    let filetypes = split(a:filetype, '\.')
                                    for i in filetypes
                                        if has_key(s:delimiterMap, i)
                                            let filetype = i
                                            break
                                        endif
                                    endfor
    1              0.000001     endif
                            
    1              0.000003     let b:NERDSexyComMarker = ''
                            
    1              0.000003     if has_key(s:delimiterMap, filetype)
                                    let b:NERDCommenterDelims = s:delimiterMap[filetype]
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = ''
                                        endif
                                    endfor
                                    for i in ['nested', 'nestedAlt']
                                        if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = 0
                                        endif
                                    endfor
                                    " if g:NERD_<filetype>_alt_style is defined, use the alternate style
                                    let b:NERDCommenterFirstInit = getbufvar(1,'NERDCommenterFirstInit')
                                    if exists('g:NERDAltDelims_'.filetype) && eval('g:NERDAltDelims_'.filetype) && !b:NERDCommenterFirstInit
                                        call s:SwitchToAlternativeDelimiters(0)
                                        let b:NERDCommenterFirstInit = 1
                                    endif
    1              0.000001     else
    1   0.000052   0.000013         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
    1              0.000001     endif
                            

FUNCTION  <SNR>66_CreateDelimMapFromCms()
    Defined: ~/.vim/pack/my_pac/start/nerdcommenter/plugin/NERD_commenter.vim:567
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000001     if &filetype ==# '' && exists('g:NERDDefaultDelims')
                                    let delims = g:NERDDefaultDelims
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(delims, i)
                                            let delims[i] = ''
                                        endif
                                    endfor
                                    return delims
    1              0.000001     endif
    1              0.000030     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}

FUNCTION  <SNR>58_pathcase()
    Defined: ~/.vim/pack/my_pac/start/completion-dict.vim/plugin/vim_dict.vim:64
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000009 	if has('win32') || has('win95') || has('win16') || has('win64')
                            		return tr(tolower(a:path), '/', "\\")
    1              0.000001 	else
    1              0.000002 		return a:path
                            	endif

FUNCTION  <SNR>58_contains()
    Defined: ~/.vim/pack/my_pac/start/completion-dict.vim/plugin/vim_dict.vim:72
Called 1 time
Total time:   0.000032
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000023   0.000009 	let name = s:pathcase(a:filename)
    1              0.000004 	for path in split(a:rtp, ',')
                            		if s:pathcase(path) == name
                            			return 1
                            		endif
    1              0.000001 	endfor
    1              0.000001 	return 0

FUNCTION  <SNR>6_BMTruncName()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/menu.vim:801
Called 2 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
    2              0.000009   let name = a:fname
    2              0.000007   if g:bmenu_max_pathlen < 5
                                let name = ""
    2              0.000002   else
    2              0.000012     let len = strlen(name)
    2              0.000007     if len > g:bmenu_max_pathlen
                                  let amountl = (g:bmenu_max_pathlen / 2) - 2
                                  let amountr = g:bmenu_max_pathlen - amountl - 3
                                  let pattern = '^\(.\{,' . amountl . '}\).\{-}\(.\{,' . amountr . '}\)$'
                                  let left = substitute(name, pattern, '\1', '')
                                  let right = substitute(name, pattern, '\2', '')
                                  if strlen(left) + strlen(right) < len
                            	let name = left . '...' . right
                                  endif
    2              0.000004     endif
    2              0.000003   endif
    2              0.000006   return name

FUNCTION  <SNR>89_IndentLinesDisable()
    Defined: ~/.vim/pack/my_pac/start/indentLine/after/plugin/indentLine.vim:209
Called 1 time
Total time:   0.000033
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000003         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        for id in w:indentLine_indentLineId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_indentLineId = []
    1              0.000000         endif
                            
    1   0.000016   0.000005         call s:ResetConcealOption()
    1              0.000001         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  <SNR>65_MRU_LoadList()
    Defined: ~/.vim/pack/my_pac/start/mru.vim/plugin/mru.vim:132
Called 1 time
Total time:   0.000894
 Self time:   0.000382

count  total (s)   self (s)
                                " If the MRU file is present, then load the list of filenames. Otherwise
                                " start with an empty list.
    1              0.000075     if filereadable(g:MRU_File)
    1              0.000255         let s:MRU_files = readfile(g:MRU_File)
    1              0.000024         if s:MRU_files[0] =~# '^\s*" Most recently edited files in Vim'
                                        " Generated by the previous version of the MRU plugin.
                                        " Discard the list.
                                        let s:MRU_files = []
    1              0.000005         elseif s:MRU_files[0] =~# '^#'
                                        " Remove the comment line
    1              0.000004             call remove(s:MRU_files, 0)
                                    else
                                        " Unsupported format
                                        let s:MRU_files = []
    1              0.000001         endif
                                else
                                    let s:MRU_files = []
    1              0.000001     endif
                            
                                " Refresh the MRU menu with the latest list of filenames
    1   0.000520   0.000008     call s:MRU_Refresh_Menu()

FUNCTION  <SNR>57_WriteLogAction()
    Defined: ~/.vim/pack/my_pac/start/activity-log.vim/plugin/activity-log.vim:141
Called 1 time
Total time:   0.002410
 Self time:   0.002410

count  total (s)   self (s)
    1              0.000281 	let l:path = expand(strftime(g:activity_log_location))
                            	" :silent exe '! mkdir -p ' substitute(l:path, '\/[^\/]*$', '', '')
    1              0.000025 	let l:dir = fnamemodify(l:path, ":p:h")
    1              0.000042 	if finddir(l:dir) == ""
                            		call mkdir(l:dir, "p")
    1              0.000001 	endif
                               
                            	" :silent exe '! echo ' . shellescape(a:message) . ' >> ' . l:path
    1              0.000288 	if filereadable(l:path)
    1              0.000276 		let l:lines = readfile(l:path)
                            	else
                            		let l:lines = []
    1              0.000001 	endif
    1              0.001484 	if writefile(l:lines+[a:message], l:path) != 0
                            		echo "activity-log: failed to write to logfile"
    1              0.000001 	endif

FUNCTION  <SNR>6_BMMunge()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/menu.vim:821
Called 2 times
Total time:   0.000489
 Self time:   0.000370

count  total (s)   self (s)
    2              0.000011   let name = a:fname
    2              0.000007   if name == ''
    1              0.000007     if !exists("g:menutrans_no_file")
                                  let g:menutrans_no_file = "[No Name]"
    1              0.000002     endif
    1              0.000003     let name = g:menutrans_no_file
    1              0.000002   else
    1              0.000156     let name = fnamemodify(name, ':p:~')
    2              0.000005   endif
                              " detach file name and separate it out:
    2              0.000014   let name2 = fnamemodify(name, ':t')
    2              0.000006   if a:bnum >= 0
    2              0.000010     let name2 = name2 . ' (' . a:bnum . ')'
    2              0.000002   endif
    2   0.000167   0.000048   let name = name2 . "\t" . <SID>BMTruncName(fnamemodify(name,':h'))
    2              0.000016   let name = escape(name, "\\. \t|")
    2              0.000023   let name = substitute(name, "&", "&&", "g")
    2              0.000016   let name = substitute(name, "\n", "^@", "g")
    2              0.000004   return name

FUNCTION  <SNR>6_BMHash()
    Defined: /private/var/containers/Bundle/Application/C6A1AA8F-77F7-4911-A2F4-56131F117F3E/iVim.app/runtime/menu.vim:743
Called 1 time
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
                              " Make name all upper case, so that chars are between 32 and 96
    1              0.000026   let nm = substitute(a:name, ".*", '\U\0', "")
    1              0.000011   if has("ebcdic")
                                " HACK: Replace all non alphabetics with 'Z'
                                "       Just to make it work for now.
                                let nm = substitute(nm, "[^A-Z]", 'Z', "g")
                                let sp = char2nr('A') - 1
    1              0.000001   else
    1              0.000005     let sp = char2nr(' ')
    1              0.000002   endif
                              " convert first six chars into a number for sorting:
    1              0.000037   return (char2nr(nm[0]) - sp) * 0x800000 + (char2nr(nm[1]) - sp) * 0x20000 + (char2nr(nm[2]) - sp) * 0x1000 + (char2nr(nm[3]) - sp) * 0x80 + (char2nr(nm[4]) - sp) * 0x20 + (char2nr(nm[5]) - sp)

FUNCTION  <SNR>62_HiPairs()
    Defined: ~/.vim/pack/my_pac/start/hiPairs.vim/plugin/hiPairs.vim:131
Called 13 times
Total time:   0.013249
 Self time:   0.012865

count  total (s)   self (s)
   13              0.000086     if a:flag == 1
    2              0.000076         let &updatetime = s:updatetime
   13              0.000026     endif
                            
   13              0.000107     let cur_time = reltime()
   13              0.000038     if a:flag == 2
    8              0.000064         let threshold = 0.1
    5              0.000009     else
    5              0.000018         let threshold = 0.1
   13              0.000022     endif
                            
   13              0.000154     if reltimefloat(reltime(s:timestamp, cur_time)) < threshold
                                    let s:timestamp = cur_time
                                    if a:flag == 0
                                        let &updatetime = 150
                                    endif
                                    return
   13              0.000025     endif
                            
   13              0.000085     let s:timestamp = cur_time
                            
   13              0.000147     if &ft == 'twoline'
                                    return
   13              0.000019     endif
                            
   13              0.000095     if !exists("b:pair_list")
                                    call s:InitMatchPairs()
   13              0.000024     endif
                            
   13              0.000071     if empty(b:pair_list)
                                    return
   13              0.000028     endif
                            
                                " Avoid that we remove the popup menu.
                                " Return when there are no colors (looks like the cursor jumps).
   13              0.000188     if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                    return
   13              0.000019     endif
                            
                                " Build an expression that detects whether the current cursor position is in
                                " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                                " skip argument.
                                " We match 'escape' for special items, such as lispEscapeSpecial.
   13              0.000136     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                            
                                " Limit the search to lines visible in the window.
   13              0.000137     let stopline_bottom = line('w$')
   13              0.000186     let stopline_top = line('w0')
                            
   13              0.000105     if !exists("b:hiPairs_old_pos")
                                    let b:hiPairs_old_pos = [[0, 0], [0, 0]]
   13              0.000020     endif
                            
   13              0.000071     let cur_line = line('.')
   13              0.000076     let cur_col = col('.')
   13              0.000101     let text = getline('.')
   13              0.000114     let cur_char = text[cur_col-1]
   13              0.000116     let idx = index(b:pair_list, cur_char)
                            
                                " Limit the search time to 1 msec to avoid a hang on very long lines.
                                " This fails when a timeout is not supported.
   13              0.000098     if mode() == 'i' || mode() == 'R'
    9              0.000060         let timeout = g:hiPairs_insert_timeout
    9              0.000082         let before_char = cur_col > 1 ? text[cur_col-2] : ''
    9              0.000096         let before_idx = index(b:pair_list, before_char)
    4              0.000006     else
    4              0.000016         let timeout = g:hiPairs_timeout
   13              0.000022     endif
                            
   13              0.000039     if a:flag == 1
    2              0.000008         let timeout = 500
    2              0.000026         let b:hiPairs_old_pos = [[0, 0], [0, 0]]
   13              0.000024     endif
                            
                                " Character under cursor is not bracket
   13              0.000041     if idx < 0
                                    " In Insert mode, character before the cursor is a right bracket
   13              0.000118         if !g:hiPairs_enable_matchParen && (mode() == 'i' || mode() == 'R') && before_idx >= 0 && before_idx % 2 == 1
                                        let [r_line, r_col] = [cur_line, cur_col-1]
                                        if s:IsBufferChanged() == 0 && b:hiPairs_old_pos[1] == [r_line, r_col]
                                            return
                                        endif
                                        call cursor(cur_line, cur_col - 1)
                                        " Search backward
                                        let [l_line, l_col] = searchpairpos(b:pair_list_ok[before_idx-1], '', b:pair_list_ok[before_idx], 'nbW', s_skip, max([stopline_top-g:hiPairs_stopline_more,1]), timeout)
                                        call cursor(cur_line, cur_col)
   13              0.000027         else
   13              0.000679             let [l_line, l_col] = searchpairpos(b:pair_list_ok[0], '', b:pair_list_ok[1], 'nbW', s_skip, max([stopline_top-g:hiPairs_stopline_more,1]), timeout)
   13              0.000054             let k = 0
   39              0.000297             for i in range(2, len(b:pair_list)-1, 2)
   26              0.001083                 let pos = searchpairpos(b:pair_list_ok[i], '', b:pair_list_ok[i+1], 'nbW', s_skip, max([l_line,stopline_top-g:hiPairs_stopline_more,1]), timeout)
   26   0.001123   0.000739                 if s:Compare(pos, [l_line, l_col]) > 0
                                                let [l_line, l_col] = pos
                                                let k = i
   26              0.000051                 endif
   39              0.000098             endfor
   13              0.000080             if [l_line, l_col] != [0, 0]
                                            if s:IsBufferChanged() == 0 && b:hiPairs_old_pos[0] == [l_line, l_col]
                                                return
                                            endif
                                            let [r_line, r_col] = searchpairpos(b:pair_list_ok[k], '', b:pair_list_ok[k+1], 'nW', s_skip, stopline_bottom+g:hiPairs_stopline_more, timeout)
   13              0.000026             else
   13              0.000514                 let [r_line, r_col] = searchpairpos(b:pair_list_ok[0], '', b:pair_list_ok[1], 'nW', s_skip, stopline_bottom+g:hiPairs_stopline_more, timeout)
   39              0.000226                 for i in range(2, len(b:pair_list)-1, 2)
   26              0.000229                     let stopline = r_line > 0 ? r_line : stopline_bottom+g:hiPairs_stopline_more
   26              0.000859                     let pos = searchpairpos(b:pair_list_ok[i], '', b:pair_list_ok[i+1], 'nW', s_skip, stopline, timeout)
   26              0.000351                     if [r_line, r_col] == [0, 0] || pos != [0, 0] && s:Compare(pos, [r_line, r_col]) < 0
   26              0.000120                         let [r_line, r_col] = pos
   26              0.000050                     endif
   39              0.000083                 endfor
   13              0.000021             endif
   13              0.000022         endif
                                " Character under cursor is a left bracket
                                elseif idx % 2 == 0
                                    let [l_line, l_col] = [cur_line, cur_col]
                                    if s:IsBufferChanged() == 0 && b:hiPairs_old_pos[0] == [l_line, l_col]
                                        return
                                    endif
                                    " Search forward
                                    let [r_line, r_col] = searchpairpos(b:pair_list_ok[idx], '', b:pair_list_ok[idx+1], 'nW', s_skip, stopline_bottom+g:hiPairs_stopline_more, timeout)
                                " Character under cursor is a right bracket
                                else
                                    let [r_line, r_col] = [cur_line, cur_col]
                                    if s:IsBufferChanged() == 0 && b:hiPairs_old_pos[1] == [r_line, r_col]
                                        return
                                    endif
                                    " Search backward
                                    let [l_line, l_col] = searchpairpos(b:pair_list_ok[idx-1], '', b:pair_list_ok[idx], 'nbW', s_skip, max([stopline_top-g:hiPairs_stopline_more,1]), timeout)
   13              0.000022     endif
                            
   13              0.000187     if b:hiPairs_old_pos[0] == [l_line, l_col] && b:hiPairs_old_pos[1] == [r_line, r_col]
   13              0.000035         return
                                else
                                    let b:hiPairs_old_pos = [[l_line, l_col], [r_line, r_col]]
                                endif
                            
                                " Remove any previous match.
                                call s:ClearMatch()
                            
                                if [r_line, r_col] == [0, 0]
                                    if [l_line, l_col] == [0, 0]
                                        return
                                    else
                                        "highlight the left unmatched pair
                                        if g:hiPairs_exists_matchaddpos
                                            silent! let id = matchaddpos("hiPairs_unmatchPair", [[l_line, l_col]])
                                        else
                                            silent! let id = matchadd("hiPairs_unmatchPair", '\%' . l_line . 'l\%' . l_col . 'c')
                                        endif
                                        call add(w:hiPairs_ids, id)
                                    endif
                                else
                                    if [l_line, l_col] == [0, 0]
                                        "highlight the right unmatched pair
                                        if g:hiPairs_exists_matchaddpos
                                            silent! let id = matchaddpos("hiPairs_unmatchPair", [[r_line, r_col]])
                                        else
                                            silent! let id = matchadd("hiPairs_unmatchPair", '\%' . r_line . 'l\%' . r_col . 'c')
                                        endif
                                        call add(w:hiPairs_ids, id)
                                    else
                                        if l_line < stopline_top && r_line > stopline_bottom
                                            return
                                        else
                                            "highlight the matching pairs
                                            if g:hiPairs_exists_matchaddpos
                                                silent! let id = matchaddpos("hiPairs_matchPair", [[l_line, l_col], [r_line, r_col]])
                                            else
                                                silent! let id = matchadd("hiPairs_matchPair", '\(\%' . l_line . 'l\%' . l_col . 'c\)\|\(\%' . r_line . 'l\%' . r_col . 'c\)')
                                            endif
                                            call add(w:hiPairs_ids, id)
                                        endif
                                    endif
                                endif

FUNCTION  <SNR>65_MRU_add_files_to_menu()
    Defined: ~/.vim/pack/my_pac/start/mru.vim/plugin/mru.vim:739
Called 2 times
Total time:   0.000831
 Self time:   0.000690

count  total (s)   self (s)
   11              0.000011     for fname in a:file_list
                                    " Escape special characters in the filename
    9              0.000051         let esc_fname = escape(fnamemodify(fname, ':t'), ".\\" . s:esc_filename_chars)
    9              0.000028         let esc_fname = substitute(esc_fname, '&', '&&', 'g')
                            
                                    " Truncate the directory name if it is long
    9              0.000021         let dir_name = fnamemodify(fname, ':h')
    9              0.000015 	if v:version >= 8.0 || has("patch-7.4.1730")
    9              0.000021 	    let len = strchars(dir_name)
                            	    " Shorten long file names by adding only few characters from
                            	    " the beginning and end.
    9              0.000007 	    if len > 30
    9              0.000034 		let dir_name = strcharpart(dir_name, 0, 10) . '...' . strcharpart(dir_name, len - 20)
    9              0.000005 	    endif
                            	else
                            	    let len = strlen(dir_name)
                            	    " Shorten long file names by adding only few characters from
                            	    " the beginning and end.
                            	    if len > 30
                            		let dir_name = strpart(dir_name, 0, 10) . '...' . strpart(dir_name, len - 20)
                            	    endif
    9              0.000006 	endif
    9              0.000077         let esc_dir_name = escape(dir_name, ".\\" . s:esc_filename_chars)
    9              0.000024         let esc_dir_name = substitute(esc_dir_name, '&', '&&', 'g')
                            
    9              0.000027 	let menu_path = '&File.&Recent\ Files.' . a:prefix . esc_fname . '\ (' . esc_dir_name . ')'
    9   0.000191   0.000050 	let esc_mfname = s:MRU_escape_filename(fname)
    9              0.000128         exe 'anoremenu <silent> ' . menu_path . " :call <SID>MRU_Edit_File('" . esc_mfname . "', 1)<CR>"
    9              0.000054 	exe 'tmenu ' . menu_path . ' Edit file ' . esc_mfname
   11              0.000012     endfor

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   19   0.017395             UltiSnips#TrackChange()
   13   0.013249   0.012865  <SNR>62_HiPairs()
   19   0.004901             <SNR>49_Highlight_Matching_Pair()
    1   0.004793   0.004255  <SNR>8_LoadFTPlugin()
    1   0.004665             <SNR>3_SynSet()
    1   0.003185   0.000412  <SNR>58_load_dict()
   15   0.002763             cursorword#matchadd()
    1   0.002741             <SNR>58_collect_location()
    1   0.002562   0.000386  <SNR>65_MRU_AddFile()
    1   0.002548   0.000138  <SNR>57_LogAction()
   11   0.002540   0.000424  cursorword#timer_callback()
    1   0.002410             <SNR>57_WriteLogAction()
    1   0.001301             <SNR>9_LoadIndent()
    2   0.001066   0.000200  <SNR>65_MRU_Refresh_Menu()
    1   0.000894   0.000382  <SNR>65_MRU_LoadList()
    1   0.000863   0.000283  <SNR>6_BMAdd()
    2   0.000831   0.000690  <SNR>65_MRU_add_files_to_menu()
    1   0.000728             <SNR>65_MRU_SaveList()
   11   0.000601             cursorword#cursormoved()
    1   0.000580   0.000165  <SNR>6_BMFilename()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   19              0.017395  UltiSnips#TrackChange()
   13   0.013249   0.012865  <SNR>62_HiPairs()
   19              0.004901  <SNR>49_Highlight_Matching_Pair()
    1              0.004665  <SNR>3_SynSet()
    1   0.004793   0.004255  <SNR>8_LoadFTPlugin()
   15              0.002763  cursorword#matchadd()
    1              0.002741  <SNR>58_collect_location()
    1              0.002410  <SNR>57_WriteLogAction()
    1              0.001301  <SNR>9_LoadIndent()
    1              0.000728  <SNR>65_MRU_SaveList()
    2   0.000831   0.000690  <SNR>65_MRU_add_files_to_menu()
   11              0.000601  cursorword#cursormoved()
   11   0.002540   0.000424  cursorword#timer_callback()
    1   0.003185   0.000412  <SNR>58_load_dict()
    1   0.002562   0.000386  <SNR>65_MRU_AddFile()
   26              0.000384  <SNR>62_Compare()
    1   0.000894   0.000382  <SNR>65_MRU_LoadList()
    2   0.000489   0.000370  <SNR>6_BMMunge()
    1   0.000863   0.000283  <SNR>6_BMAdd()
    2   0.001066   0.000200  <SNR>65_MRU_Refresh_Menu()

